// Generated by CoffeeScript 1.3.3
var consolidate, dox, exec, fs, mkdirp, path, spawn, watchr, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

fs = require("fs");

dox = require("dox");

path = require("path");

_ref = require("child_process"), exec = _ref.exec, spawn = _ref.spawn;

watchr = require("watchr");

mkdirp = require("mkdirp");

consolidate = require("consolidate");

/*
## Docker Constructor

Creates a new docker instance. All methods are called on one instance of this object.

Input arguments are an object containing any of the keys `inDir`, `outDir`, `tplDir`, `onlyUpdated`, `colourScheme`, `ignoreHidden`, `sidebarState`, `exclude`
*/


exports.Docker = (function() {

  function Docker(opts) {
    this.xdoxTemplate = __bind(this.xdoxTemplate, this);

    this.xcodeFileTemplate = __bind(this.xcodeFileTemplate, this);

    this.xrenderTemplate = __bind(this.xrenderTemplate, this);

    this.compileTemplate = __bind(this.compileTemplate, this);

    this.render = __bind(this.render, this);

    this.outFile = __bind(this.outFile, this);

    this.copySharedResources = __bind(this.copySharedResources, this);

    this.renderMarkdownHtml = __bind(this.renderMarkdownHtml, this);

    this.renderCodeHtml = __bind(this.renderCodeHtml, this);

    this.addAnchors = __bind(this.addAnchors, this);

    this.highlighExtractedCode = __bind(this.highlighExtractedCode, this);

    this.extractDocCode = __bind(this.extractDocCode, this);

    this.processDocCodeBlocks = __bind(this.processDocCodeBlocks, this);

    this.highlight = __bind(this.highlight, this);

    this.pygments = __bind(this.pygments, this);

    this.languageParams = __bind(this.languageParams, this);

    this.parseSections = __bind(this.parseSections, this);

    this.fileIsNewer = __bind(this.fileIsNewer, this);

    this.decideWhetherToProcess = __bind(this.decideWhetherToProcess, this);

    this.generateDoc = __bind(this.generateDoc, this);

    this.processNextFile = __bind(this.processNextFile, this);

    this.addFileToTree = __bind(this.addFileToTree, this);

    this.queueFile = __bind(this.queueFile, this);

    this.addNextFile = __bind(this.addNextFile, this);

    this.clean = __bind(this.clean, this);

    this.finished = __bind(this.finished, this);

    this.watch = __bind(this.watch, this);

    this.doc = __bind(this.doc, this);

    this.parseOpts = __bind(this.parseOpts, this);
    this.parseOpts(opts);
    this.running = false;
    this.scanQueue = [];
    this.files = [];
    this.tree = {};
  }

  Docker.prototype.parseOpts = function(opts) {
    var defaults, i, _fn;
    defaults = {
      inDir: path.resolve("."),
      outDir: path.resolve("doc"),
      tplDir: path.join(path.resolve(__dirname), "res"),
      tplEngine: "internal",
      tplExtension: "jst",
      markdownEngine: "marked",
      onlyUpdated: false,
      colourScheme: "default",
      ignoreHidden: false,
      sidebarState: true,
      exclude: false
    };
    _fn = function(i) {
      if (defaults.hasOwnProperty(i) && typeof opts[i] === "undefined") {
        return opts[i] = defaults[i];
      }
    };
    for (i in defaults) {
      _fn(i);
    }
    this.inDir = opts.inDir.replace(/\/$/, "");
    this.outDir = opts.outDir;
    this.tplDir = opts.tplDir;
    this.tplEngine = opts.tplEngine;
    this.tplExtension = opts.tplExtension;
    this.markdownEngine = opts.markdownEngine;
    this.onlyUpdated = !!opts.onlyUpdated;
    this.colourScheme = opts.colourScheme;
    this.ignoreHidden = !!opts.ignoreHidden;
    this.sidebarState = opts.sidebarState;
    if (typeof opts.exclude === "string") {
      this.excludePattern = new RegExp("^(" + opts.exclude.replace(/\./g, "\\.").replace(/\*/g, ".*").replace(/,/g, "|") + ")(/|$)");
    } else {
      this.excludePattern = false;
    }
    if (opts.colorScheme != null) {
      opts.colourScheme = opts.colorScheme;
    }
    switch (this.markdownEngine) {
      case "gfm":
        return this._renderMarkdown = require("github-flavored-markdown").parse;
      case "showdown":
        return this._renderMarkdown = require("" + __dirname + "/../res/showdown").Showdown.makeHtml;
      case "marked":
        this._renderMarkdown = require("marked");
        return this._renderMarkdown.setOptions({
          gfm: false,
          pedantic: false,
          sanitize: false
        });
    }
  };

  Docker.prototype.doc = function(files) {
    this.running = true;
    [].push.apply(this.scanQueue, files);
    return this.addNextFile();
  };

  /*
    ## Docker.prototype.watch
  
    Watches the input directory for file changes and updates docs whenever a file is updated
  
    @param {Array} files Array of file paths relative to the `inDir` to generate documentation for.
  */


  Docker.prototype.watch = function(files) {
    var self, update, uto;
    this.watching = true;
    this.watchFiles = files;
    uto = false;
    self = this;
    update = function() {
      if (self.running) {
        return (uto = setTimeout(update, 250));
      }
      self.clean();
      self.doc(self.watchFiles);
      return uto = false;
    };
    watchr.watch(this.inDir, (function() {
      if (!uto) {
        return uto = setTimeout(update, 250);
      }
    }), null);
    return this.doc(files);
  };

  /*
    ## Docker.prototype.finished
  
    Callback function fired when processing is finished.
  */


  Docker.prototype.finished = function() {
    this.running = false;
    if (this.watching) {
      this.onlyUpdated = true;
      return console.log("Done. Waiting for changes...");
    } else {
      return console.log("Done.");
    }
  };

  /*
    ## Docker.prototype.clean
  
    Clears out any instance variables so this docker can be rerun
  */


  Docker.prototype.clean = function() {
    this.scanQueue = [];
    this.files = [];
    return this.tree = {};
  };

  /*
    ## Docker.prototype.addNextFile
  
    Process the next file on the scan queue. If it's a directory, list all the children and queue those.
    If it's a file, add it to the queue.
  */


  Docker.prototype.addNextFile = function() {
    var cb, currFile, filename, self;
    self = this;
    if (this.scanQueue.length > 0) {
      filename = this.scanQueue.shift();
      if (this.excludePattern && this.excludePattern.test(filename)) {
        return this.addNextFile();
      }
      currFile = path.resolve(this.inDir, filename);
      cb = function(err, stat) {
        if (stat != null ? stat.isSymbolicLink() : void 0) {
          return fs.readlink(currFile, function(err, link) {
            currFile = path.resolve(path.dirname(currFile), link);
            return fs.exists(currFile, function(exists) {
              if (!exists) {
                console.error("Unable to follow symlink to " + currFile + ": file does not exist");
                return self.addNextFile();
              } else {
                return fs.lstat(currFile, cb);
              }
            });
          });
        } else if (stat != null ? stat.isDirectory() : void 0) {
          return fs.readdir(path.resolve(self.inDir, filename), function(err, list) {
            var maybe, _i, _len;
            for (_i = 0, _len = list.length; _i < _len; _i++) {
              maybe = list[_i];
              if (self.ignoreHidden && maybe.charAt(0).match(/[\._]/)) {
                continue;
              }
              self.scanQueue.push(path.join(filename, maybe));
            }
            return self.addNextFile();
          });
        } else {
          self.queueFile(filename);
          return self.addNextFile();
        }
      };
      return fs.lstat(currFile, cb);
    } else {
      return this.processNextFile();
    }
  };

  /*
    ## Docker.prototype.queueFile
  
    Queues a file for processing, and additionally stores it in the folder tree
  
    @param {string} filename Name of the file to queue
  */


  Docker.prototype.queueFile = function(filename) {
    return this.files.push(filename);
  };

  /*
    ## Docker.prototype.addFileToFree
  
    Adds a file to the file tree to show in the sidebar. This used to be in `queueFile` but
    since we're now only deciding whether or not the file can be included at the point of
    reading it, this has to happen later.
  
    @param {string} filename Name of file to add to the tree
  */


  Docker.prototype.addFileToTree = function(filename) {
    var bits, currDir, i, pathSeparator;
    pathSeparator = path.join("a", "b").replace(/(^.*a|b.*$)/g, "");
    filename = filename.replace(new RegExp("^" + pathSeparator.replace(/([\/\\])/g, "\\$1")), "");
    bits = filename.split(pathSeparator);
    currDir = this.tree;
    i = 0;
    while (i < bits.length - 1) {
      if (!currDir.dirs) {
        currDir.dirs = {};
      }
      if (!currDir.dirs[bits[i]]) {
        currDir.dirs[bits[i]] = {};
      }
      currDir = currDir.dirs[bits[i]];
      i += 1;
    }
    if (!currDir.files) {
      currDir.files = [];
    }
    return currDir.files.push(bits[bits.length - 1]);
  };

  /*
    ## Docker.prototype.processNextFile
  
    Take the next file off the queue and process it
  */


  Docker.prototype.processNextFile = function() {
    var _this = this;
    if (this.files.length > 0) {
      return this.generateDoc(this.files.shift(), function() {
        return _this.processNextFile();
      });
    } else {
      return this.copySharedResources();
    }
  };

  /*
    ## Docker.prototype.generateDoc
  
    _This is where the magic happens_
  
    Generate the documentation for a file
  
    @param {string} filename File name to generate documentation for
    @param {function} cb Callback function to execute when we're done
  */


  Docker.prototype.generateDoc = function(infilename, cb) {
    var filename,
      _this = this;
    this.running = true;
    filename = path.resolve(this.inDir, infilename);
    return this.decideWhetherToProcess(filename, function(shouldProcess) {
      if (!shouldProcess) {
        return cb();
      }
      return fs.readFile(filename, "utf-8", function(err, data) {
        var lang, sections;
        if (err) {
          throw err;
        }
        lang = _this.languageParams(filename, data);
        if (lang === false) {
          return cb();
        }
        _this.addFileToTree(infilename);
        switch (_this.languages[lang].type) {
          case "markdown":
            return _this.renderMarkdownHtml(data, filename, cb);
          case "code":
            break;
          default:
            sections = _this.parseSections(data, lang);
            return _this.highlight(sections, lang, function() {
              return _this.renderCodeHtml(sections, filename, cb);
            });
        }
      });
    });
  };

  /*
    ## Docker.prototype.decideWhetherToProcess
  
    Decide whether or not a file should be processed. If the `onlyUpdated`
    flag was set on initialization, only allow processing of files that
    are newer than their counterpart generated doc file.
  
    Fires a callback function with either true or false depending on whether
    or not the file should be processed
  
    @param {string} filename The name of the file to check
    @param {function} callback Callback function
  */


  Docker.prototype.decideWhetherToProcess = function(filename, callback) {
    var outFile;
    if (!this.onlyUpdated) {
      return callback(true);
    }
    outFile = this.outFile(filename);
    return this.fileIsNewer(filename, outFile, callback);
  };

  /*
    ## Docker.prototype.fileIsNewer
  
    Sees whether one file is newer than another
  
    @param {string} file File to check
    @param {string} otherFile File to compare to
    @param {function} callback Callback to fire with true if file is newer than otherFile
  */


  Docker.prototype.fileIsNewer = function(file, otherFile, callback) {
    return fs.stat(otherFile, function(err, outStat) {
      if (err && err.code === "ENOENT") {
        return callback(true);
      }
      return fs.stat(file, function(err, inStat) {
        return callback(+inStat.mtime > +outStat.mtime);
      });
    });
  };

  /*
    ## Docker.prototype.parseSections
  
    Parse the content of a file into individual sections.
    A section is defined to be one block of code with an accompanying comment
  
    Returns an array of section objects, which take the form
    ```js
    {
    doc_text: 'foo', // String containing comment content
    code_text: 'bar' // Accompanying code
    }
    ```
    @param {string} data The contents of the script file
    @param {string} language The language of the script file
  
    @return {Array} array of section objects
  */


  Docker.prototype.parseSections = function(data, language) {
    var async, codeLines, commentRegex, doxData, inMultiLineComment, md, multiLine, params, section, sections,
      _this = this;
    md = function(a, stripParas) {
      var h;
      h = _this._renderMarkdown(a.replace(/(^\s*|\s*$)/, ""));
      return (stripParas ? h.replace(/<\/?p>/g, "") : h);
    };
    codeLines = data.split("\n");
    sections = [];
    params = this.languages[language];
    section = {
      docs: "",
      code: ""
    };
    inMultiLineComment = false;
    multiLine = "";
    doxData = void 0;
    commentRegex = new RegExp("^\\s*" + params.comment + "\\s?");
    async = require("async");
    async.forEachSeries(codeLines, function(line, forEachCb) {
      var matchable;
      matchable = line.replace(/(["'])(?:\\.|(?!\1).)*\1/g, "");
      if (params.multiLine) {
        if (inMultiLineComment) {
          if (line.match(params.multiLine[1])) {
            inMultiLineComment = false;
            if (params.dox) {
              multiLine += line;
              try {
                multiLine = multiLine.replace(params.multiLine[0], "/**").replace(params.multiLine[1], "*/").replace(/\n (?:[^\*])/g, "\n * ");
                doxData = dox.parseComments(multiLine, {
                  raw: true
                })[0];
                doxData.md = md;
                return _this.render("dox", doxData, function(err, rendered) {
                  if (err) {
                    throw err;
                  }
                  section.docs += rendered;
                  return forEachCb();
                });
              } catch (e) {
                console.log("Dox error: " + e);
                multiLine += line.replace(params.multiLine[1], "") + "\n";
                section.docs += "\n" + multiLine.replace(params.multiLine[0], "") + "\n";
              }
            } else {
              multiLine += line.replace(params.multiLine[1], "") + "\n";
              section.docs += "\n" + multiLine.replace(params.multiLine[0], "") + "\n";
            }
            multiLine = "";
          } else {
            multiLine += line + "\n";
          }
          return forEachCb();
        } else if (matchable.match(params.multiLine[0]) && !matchable.replace(params.multiLine[0], "").match(params.multiLine[1]) && !matchable.split(params.multiLine[0])[0].match(commentRegex)) {
          if (section.code) {
            if (!section.code.match(/^\s*$/) || !section.docs.match(/^\s*$/)) {
              sections.push(section);
            }
            section = {
              docs: "",
              code: ""
            };
          }
          inMultiLineComment = true;
          multiLine = line + "\n";
          return forEachCb();
        }
      }
      if (matchable.match(commentRegex) && (!params.commentsIgnore || !matchable.match(params.commentsIgnore)) && !matchable.match(/#!/)) {
        if (section.code) {
          if (!section.code.match(/^\s*$/) || !section.docs.match(/^\s*$/)) {
            sections.push(section);
          }
          section = {
            docs: "",
            code: ""
          };
        }
        section.docs += line.replace(commentRegex, "") + "\n";
      } else {
        if (!params.commentsIgnore || !line.match(params.commentsIgnore)) {
          section.code += line + "\n";
        }
      }
      return forEachCb();
    });
    sections.push(section);
    return sections;
  };

  /*
    ## Docker.prototype.languageParams
  
    Provides language-specific params for a given file name.
  
    @param {string} filename The name of the file to test
    @param {string} filedata The contents of the file (to check for shebang)
    @return {object} Object containing all of the language-specific params
  */


  Docker.prototype.languageParams = function(filename, filedata) {
    var ext, i, j, match, shebangRegex;
    ext = path.extname(filename);
    ext = ext.replace(/^\./, "");
    if (ext === ".C") {
      return "cpp";
    }
    ext = ext.toLowerCase();
    for (i in this.languages) {
      if (!this.languages.hasOwnProperty(i)) {
        continue;
      }
      if (this.languages[i].extensions.indexOf(ext) !== -1) {
        return i;
      }
    }
    shebangRegex = /^\n*#!\s*(?:\/usr\/bin\/env)?\s*(?:[^\n]*\/)*([^\/\n]+)(?:\n|$)/;
    match = shebangRegex.exec(filedata);
    if (match) {
      for (j in this.languages) {
        if (!this.languages.hasOwnProperty(j)) {
          continue;
        }
        if (this.languages[j].executables && this.languages[j].executables.indexOf(match[1]) !== -1) {
          return j;
        }
      }
    }
    return false;
  };

  Docker.prototype.languages = {
    javascript: {
      extensions: ["js"],
      executables: ["node"],
      comment: "//",
      multiLine: [/\/\*\*?/, /\*\//],
      commentsIgnore: /^\s*\/\/=/,
      dox: true
    },
    coffeescript: {
      extensions: ["coffee"],
      executables: ["coffee"],
      comment: "#",
      multiLine: [/^#{3}\s*$/m, /^#{3}\s*$/m],
      dox: true
    },
    ruby: {
      extensions: ["rb"],
      executables: ["ruby"],
      comment: "#",
      multiLine: [/\=begin/, /\=end/]
    },
    python: {
      extensions: ["py"],
      executables: ["python"],
      comment: "#"
    },
    perl: {
      extensions: ["pl", "pm"],
      executables: ["perl"],
      comment: "#"
    },
    c: {
      extensions: ["c"],
      executables: ["gcc"],
      comment: "//",
      multiLine: [/\/\*/, /\*\//]
    },
    objc: {
      extensions: ["m", "h"],
      executables: ["clang", "gcc"],
      dox: true,
      comment: "//",
      multiLine: [/\/\*/, /\*\//]
    },
    cpp: {
      extensions: ["cc", "cpp"],
      executables: ["g++"],
      comment: "//",
      multiLine: [/\/\*/, /\*\//]
    },
    csharp: {
      extensions: ["cs"],
      comment: "//",
      multiLine: [/\/\*/, /\*\//]
    },
    java: {
      extensions: ["java"],
      comment: "//",
      multiLine: [/\/\*/, /\*\//],
      dox: true
    },
    php: {
      extensions: ["php", "php3", "php4", "php5"],
      executables: ["php"],
      comment: "//",
      multiLine: [/\/\*/, /\*\//],
      dox: true
    },
    actionscript: {
      extensions: ["as"],
      comment: "//",
      multiLine: [/\/\*/, /\*\//]
    },
    sh: {
      extensions: ["sh"],
      executables: ["bash", "sh", "zsh"],
      comment: "#"
    },
    yaml: {
      extensions: ["yaml", "yml"],
      comment: "#"
    },
    markdown: {
      extensions: ["md", "mkd", "markdown"],
      type: "markdown"
    }
  };

  /*
    ## Docker.prototype.pygments
  
    Runs a given block of code through pygments
  
    @param {string} data The code to give to Pygments
    @param {string} language The name of the Pygments lexer to use
    @param {function} cb Callback to fire with Pygments output
  */


  Docker.prototype.pygments = function(data, language, cb) {
    var out, pyg, pygArgs;
    pygArgs = ["-g"];
    if (language) {
      pygArgs = ["-l", language];
    }
    pyg = spawn("pygmentize", pygArgs.concat(["-f", "html", "-O", "encoding=utf-8,tabsize=2"]));
    pyg.stderr.on("data", function(err) {
      return console.error(err.toString());
    });
    pyg.stdin.on("error", function(err) {
      console.error("Unable to write to Pygments stdin: ", err);
      return process.exit(1);
    });
    out = "";
    pyg.stdout.on("data", function(data) {
      return out += data.toString();
    });
    pyg.on("exit", function() {
      return cb(out);
    });
    if (pyg.stdin.writable) {
      pyg.stdin.write(data);
      return pyg.stdin.end();
    }
  };

  /*
    ## Docker.prototype.highlight
  
    Highlights all the sections of a file using **pygments**
    Given an array of section objects, loop through them, and for each
    section generate pretty html for the comments and the code, and put them in
    `docHtml` and `codeHtml` respectively
  
    @param {Array} sections Array of section objects
    @param {string} language Language ith which to highlight the file
    @param {function} cb Callback function to fire when we're done
  */


  Docker.prototype.highlight = function(sections, language, cb) {
    var i, input, params, self,
      _this = this;
    params = this.languages[language];
    self = this;
    input = [];
    i = 0;
    while (i < sections.length) {
      input.push(sections[i].code);
      i += 1;
    }
    input = input.join("\n" + params.comment + "----{DIVIDER_THING}----\n");
    return this.pygments(input, language, function(out) {
      var bits, section, _i, _len;
      out = out.replace(/^\s*<div class="highlight"><pre>/, "").replace(/<\/pre><\/div>\s*$/, "");
      bits = out.split(new RegExp("\\n*<span class=\"c[1p]?\">" + params.comment + "----\\{DIVIDER_THING\\}----<\\/span>\\n*"));
      i = 0;
      for (i = _i = 0, _len = sections.length; _i < _len; i = ++_i) {
        section = sections[i];
        section.codeHtml = "<div class=\"highlight\"><pre>" + bits[i] + "</pre></div>";
        section.docHtml = _this._renderMarkdown(section.docs);
        i += 1;
      }
      return self.processDocCodeBlocks(sections, cb);
    });
  };

  /*
    ## Docker.prototype.processDocCodeBlocks
  
    Goes through all the HTML generated from comments, finds any code blocks
    and highlights them
  
    @param {Array} sections Sections array as above
    @param {function} cb Callback to fire when done
  */


  Docker.prototype.processDocCodeBlocks = function(sections, cb) {
    var i, next, self;
    self = this;
    i = 0;
    next = function() {
      if (i === sections.length) {
        return cb();
      }
      return self.extractDocCode(sections[i].docHtml, function(html) {
        sections[i].docHtml = html;
        i = i + 1;
        return next();
      });
    };
    return next();
  };

  /*
    ## Docker.prototype.extractDocCode
  
    Extract and highlight code blocks in formatted HTML output from showdown
  
    @param {string} html The HTML to process
    @param {function} cb Callback function to fire when done
  */


  Docker.prototype.extractDocCode = function(html, cb) {
    var codeBlocks;
    codeBlocks = [];
    html = html.replace(/<pre><code(\slanguage='([a-z]*)')?>([^<]*)<\/code><\/pre>/g, function(wholeMatch, langBlock, language, block) {
      if (langBlock === "" || language === "") {
        return "<div class='highlight'>" + wholeMatch + "</div>";
      }
      block = block.replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&amp;/, "&");
      return "\n\n~C" + codeBlocks.push({
        language: language,
        code: block,
        i: codeBlocks.length + 1
      }) + "C\n\n";
    });
    return this.highlighExtractedCode(html, codeBlocks, cb);
  };

  /*
    ## Docker.prototype.highlightExtractedCode
  
    Loops through all extracted code blocks and feeds them through pygments
    for code highlighting. Unfortunately the only way to do this that's able
    to cater for all situations is to spawn a new pygments process for each
    code block (as different blocks might be in different languages). If anyone
    knows of a more efficient way of doing this, please let me know.
  
    @param {string} html The HTML the code has been extracted from
    @param {Array} codeBlocks Array of extracted code blocks as above
    @param {function} cb Callback to fire when we're done with processed HTML
  */


  Docker.prototype.highlighExtractedCode = function(html, codeBlocks, cb) {
    var next, self;
    self = this;
    next = function() {
      var nextBlock;
      if (codeBlocks.length === 0) {
        return cb(html);
      }
      nextBlock = codeBlocks.shift();
      return self.pygments(nextBlock.code, nextBlock.language, function(out) {
        out = out.replace(/<pre>/, "<pre><code>").replace(/<\/pre>/, "</code></pre>");
        html = html.replace("\n~C" + nextBlock.i + "C\n", out);
        return next();
      });
    };
    return next();
  };

  /*
    ## Docker.prototype.addAnchors
  
    Automatically assign an id to each section based on any headings.
  
    @param {object} section The section object to look at
    @param {number} idx The index of the section in the whole array.
  */


  Docker.prototype.addAnchors = function(docHtml, idx, headings) {
    if (docHtml.match(/<h[0-9]>/)) {
      docHtml = docHtml.replace(/(<h([0-9])>)(.*)(<\/h\2>)/g, function(a, start, level, middle, end) {
        var id;
        id = middle.replace(/<[^>]*>/g, "").toLowerCase().replace(/[^a-zA-Z0-9\_\.]/g, "-");
        headings.push({
          id: id,
          text: middle.replace(/<[^>]*>/g, ""),
          level: level
        });
        return "\n<div class=\"pilwrap\" id=\"" + id + "\">\n  " + start + "\n    <a href=\"#" + id + "\" class=\"pilcrow\">&#182;</a>\n    " + middle + "\n  " + end + "\n</div>\n";
      });
    } else {
      docHtml = "\n<div class=\"pilwrap\">" + "\n  <a class=\"pilcrow\" href=\"#section-" + (idx + 1) + "\" id=\"section-" + (idx + 1) + "\">&#182;</a>" + "\n</div>\n" + docHtml;
    }
    return docHtml;
  };

  /*
    ## Docker.prototype.renderCodeHtml
  
    Given an array of sections, render them all out to a nice HTML file
  
    @param {Array} sections Array of sections containing parsed data
    @param {string} filename Name of the file being processed
    @param {function} cb Callback function to fire when we're done
  */


  Docker.prototype.renderCodeHtml = function(sections, filename, cb) {
    var headings, i, levels, outDir, outFile, pathSeparator, relDir, relativeOut, section, self, _i, _len,
      _this = this;
    self = this;
    outFile = this.outFile(filename);
    headings = [];
    outDir = path.dirname(outFile);
    pathSeparator = path.join("a", "b").replace(/(^.*a|b.*$)/g, "");
    relativeOut = path.resolve(outDir).replace(path.resolve(this.outDir), "").replace(/^[\/\\]/, "");
    levels = (relativeOut === "" ? 0 : relativeOut.split(pathSeparator).length);
    relDir = Array(levels + 1).join("../");
    i = 0;
    for (_i = 0, _len = sections.length; _i < _len; _i++) {
      section = sections[_i];
      section.docHtml = this.addAnchors(section.docHtml, i, headings);
      i++;
    }
    return this.render("code", {
      title: path.basename(filename),
      sections: sections
    }, function(err, renderedCode) {
      var locals;
      if (err) {
        throw err;
      }
      locals = {
        title: path.basename(filename),
        relativeDir: relDir,
        content: renderedCode,
        headings: headings,
        sidebar: _this.sidebarState,
        colourScheme: _this.colourScheme,
        filename: filename.replace(_this.inDir, "").replace(/^[\/\\]/, "")
      };
      return _this.render("tmpl", locals, function(err, rendered) {
        if (err) {
          throw err;
        }
        return _this.writeFile(outFile, rendered, "Generated: " + (outFile.replace(_this.outDir, '')), cb);
      });
    });
  };

  /*
    ## Docker.prototype.renderMarkdownHtml
  
    Renders the output for a Markdown file into HTML
  
    @param {string} content The markdown file content
    @param {string} filename Name of the file being processed
    @param {function} cb Callback function to fire when we're done
  */


  Docker.prototype.renderMarkdownHtml = function(content, filename, cb) {
    content = this._renderMarkdown(content);
    return this.extractDocCode(content, function(content) {
      var headings, levels, locals, outDir, outFile, pathSeparator, relDir, relativeOut,
        _this = this;
      headings = [];
      content = "<div class=\"docs markdown\">" + (this.addAnchors(content, 0, headings)) + "</div>";
      outFile = this.outFile(filename);
      outDir = path.dirname(outFile);
      pathSeparator = path.join("a", "b").replace(/(^.*a|b.*$)/g, "");
      relativeOut = path.resolve(outDir).replace(path.resolve(this.outDir), "").replace(/^[\/\\]/, "");
      levels = (relativeOut === "" ? 0 : relativeOut.split(pathSeparator).length);
      relDir = Array(levels + 1).join("../");
      locals = {
        title: path.basename(filename),
        relativeDir: relDir,
        content: content,
        headings: headings,
        colourScheme: this.colourScheme,
        sidebar: this.sidebarState,
        filename: filename.replace(this.inDir, "").replace(/^[\\\/]/, "")
      };
      return this.render("tmpl", locals, function(err, rendered) {
        return _this.writeFile(outFile, rendered, "Generated: " + outFile.replace(_this.outDir, ""), cb);
      });
    }).bind(this);
  };

  /*
    ## Docker.prototype.copySharedResources
  
    Copies the shared CSS and JS files to the output directories
  */


  Docker.prototype.copySharedResources = function() {
    var done, path_bryntax_css, path_colorscheme_css, path_out_doc_filelist_js, path_out_doc_script_js, path_out_doc_style_css, path_script_js, toDo,
      _this = this;
    toDo = 3;
    done = function() {
      if (!--toDo) {
        return _this.finished();
      }
    };
    path_script_js = path.join(path.dirname(__filename), "..", "res", "script.js");
    path_bryntax_css = path.join(path.dirname(__filename), "..", "res", "css", "bryntax.css");
    path_colorscheme_css = path.join(path.dirname(__filename), "..", "res", "css", "" + this.colourScheme + ".css");
    path_out_doc_script_js = path.join(this.outDir, "doc-script.js");
    path_out_doc_style_css = path.join(this.outDir, "doc-style.css");
    path_out_doc_filelist_js = path.join(this.outDir, "doc-filelist.js");
    fs.readFile(path_script_js, function(err, file) {
      return _this.writeFileIfDifferent(path_out_doc_script_js, file, "Copied JS to doc-script.js", done);
    });
    fs.readFile(path_colorscheme_css, function(err, file) {
      return exec("pygmentize -S " + _this.colourScheme + " -f html -a 'body .highlight'", function(code, stdout, stderr) {
        var bryntax;
        if (code || stderr !== "") {
          console.error("Error generating CSS: \n" + stderr);
          process.exit();
        }
        bryntax = fs.readFileSync(path_bryntax_css);
        return _this.writeFileIfDifferent(path_out_doc_style_css, "" + (file.toString()) + stdout + (bryntax.toString()), "Copied " + _this.colourScheme + ".css to doc-style.css", done);
      });
    });
    return this.writeFileIfDifferent(path_out_doc_filelist_js, "var tree=" + JSON.stringify(this.tree) + ";", "Saved file tree to doc-filelist.js", done);
  };

  Docker.prototype.outFile = function(filename) {
    return path.normalize(filename.replace(path.resolve(this.inDir), this.outDir) + ".html");
  };

  Docker.prototype.render = function(tplName, locals, cb) {
    var rendered, templatePath, tplFn;
    templatePath = path.join(this.tplDir, "" + tplName + "." + this.tplExtension);
    if (this.tplEngine === "internal") {
      tplFn = this.compileTemplate(fs.readFileSync(templatePath).toString());
      rendered = tplFn(locals);
      return cb(null, rendered);
    } else {
      return consolidate[this.tplEngine](templatePath, locals, cb);
    }
  };

  Docker.prototype.compileTemplate = function(str) {
    return new Function("obj", "var p=[],print=function(){p.push.apply(p,arguments);};" + "with(obj){p.push('" + str.replace(/[\r\t]/g, " ").replace(/(>)\s*\n+(\s*<)/g, "$1\n$2").replace(/(?=<%[^=][^%]*)%>\s*\n*\s*<%(?=[^=])/g, "").replace(/%>\s*(?=\n)/g, "%>").replace(/(?=\n)\s*<%/g, "<%").replace(/\n/g, "~K").replace(/~K(?=[^%]*%>)/g, " ").replace(/~K/g, "\\n").replace(/'(?=[^%]*%>)/g, "\t").split("'").join("\\'").split("\t").join("'").replace(/<%=(.+?)%>/g, "',$1,'").split("<%").join("');").split("%>").join("p.push('") + "');}return p.join('');");
  };

  Docker.prototype.xrenderTemplate = function(obj) {
    var tmplFile;
    if (!this.__tmpl) {
      tmplFile = path.join(this.tplDir, "tmpl.jst");
      this.__tmpl = this.compileTemplate(fs.readFileSync(tmplFile).toString());
    }
    return this.__tmpl(obj);
  };

  Docker.prototype.xcodeFileTemplate = function(obj) {
    var tmplFile;
    if (!this.__codeTmpl) {
      tmplFile = path.join(path.dirname(__filename), "..", "res", "code.jst");
      this.__codeTmpl = this.compileTemplate(fs.readFileSync(tmplFile).toString());
    }
    return this.__codeTmpl(obj);
  };

  Docker.prototype.xdoxTemplate = function(obj) {
    var tmplFile;
    if (!this.__doxtmpl) {
      tmplFile = path.join(path.dirname(__filename), "..", "res", "dox.jst");
      this.__doxtmpl = this.compileTemplate(fs.readFileSync(tmplFile).toString());
    }
    return this.__doxtmpl(obj);
  };

  Docker.prototype.writeFile = function(filename, fileContent, doneLog, doneCallback) {
    var outDir;
    outDir = path.dirname(filename);
    return mkdirp(outDir, function() {
      return fs.unlink(filename, function() {
        return fs.writeFile(filename, fileContent, function() {
          if (doneLog) {
            console.log(doneLog);
          }
          if (doneCallback) {
            return doneCallback();
          }
        });
      });
    });
  };

  Docker.prototype.writeFileIfDifferent = function(filename, fileContent, doneLog, doneCallback) {
    var outDir;
    outDir = path.dirname(filename);
    return fs.readFile(filename, function(err, content) {
      if (!err && content.toString() === fileContent.toString()) {
        if (doneCallback != null) {
          return doneCallback();
        }
      } else {
        return mkdirp(outDir, function() {
          return fs.unlink(filename, function() {
            return fs.writeFile(filename, fileContent, function() {
              if (doneLog) {
                console.log(doneLog);
              }
              if (doneCallback) {
                return doneCallback();
              }
            });
          });
        });
      }
    });
  };

  return Docker;

})();
